<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Replika - Etusivu</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=Raleway:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --primary-color: #00b7eb;
            --primary-hover: #0099cc;
        }
        
        body {
            font-family: 'Raleway', sans-serif;
        }
        
        .font-courier {
            font-family: 'Courier Prime', monospace;
        }
        
        .text-primary {
            color: var(--primary-color);
        }
        
        .bg-primary {
            background-color: var(--primary-color);
        }
        
        .border-primary {
            border-color: var(--primary-color);
        }
        
        .hover\:bg-primary-hover:hover {
            background-color: var(--primary-hover);
        }
        
        .navbar {
            background: rgba(0, 0, 0, 0.7);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 50;
        }
        
        .navbar::before {
            content: '';
            position: absolute;
            inset: 0;
            height: 200%;
            backdrop-filter: blur(16px);
            mask-image: linear-gradient(
                to bottom,
                black 0% 50%, 
                transparent 50% 100%
            );
            pointer-events: none;
            z-index: -1;
        }
        
        @supports not (backdrop-filter: blur(16px)) {
            .navbar {
                background: rgba(0, 0, 0, 0.95);
            }
        }
        
        .dropdown:hover .dropdown-menu {
            display: block;
        }
        
        .pulse-animation {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .hero-bg {
            background: linear-gradient(to bottom, black 0%, var(--primary-hover) 100%);
            overflow: hidden;
            position: relative;
        }
        
        #particle-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .particle {
            fill: rgba(255, 255, 255, 0.8);
            opacity: 0.7;
        }
    </style>
</head>
<body class="bg-black">
    <!-- Navigation -->
    <nav class="fixed w-full top-0 shadow-md navbar z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-16">
                <!-- Logo -->
                <div class="flex-shrink-0">
                    <h1 class="text-2xl font-courier font-bold text-white">Replika</h1>
                </div>
                
                <!-- Hamburger menu button (always visible) -->
                <div>
                    <button class="text-white hover:text-primary" onclick="toggleMobileMenu()">
                        <!-- Hamburger icon (visible when menu is closed) -->
                        <svg id="hamburger-icon" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                        </svg>
                        <!-- Cross icon (hidden when menu is closed) -->
                        <svg id="cross-icon" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Mobile Menu -->
        <div id="mobile-menu" class="hidden">
            <div class="px-2 pt-2 pb-3 space-y-1 sm:px-3 bg-black bg-opacity-90 border-t border-gray-600">
                <a href="#" class="text-white hover:text-primary block px-3 py-2 text-base font-medium">Etusivu</a>
                <a href="#" class="text-white hover:text-primary block px-3 py-2 text-base font-medium">Palvelut</a>
                <a href="#" class="text-white hover:text-primary block px-3 py-2 text-base font-medium">Tietoa meistä</a>
                <a href="#" class="text-white hover:text-primary block px-3 py-2 text-base font-medium">Yhteystiedot</a>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main>
        <!-- Hero Section -->
        <section class="hero-bg h-screen flex items-center justify-center relative overflow-hidden">
            <svg id="particle-container" width="100%" height="100%"></svg>
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 relative z-10">
                <div class="flex flex-col items-start">
                    <h1 class="text-7xl md:text-8xl lg:text-9xl font-courier font-bold text-white mb-8 leading-tight">
                        Replika
                    </h1>
                    <div class="text-left">
                        <p class="text-white text-lg md:text-xl font-courier font-light leading-relaxed">
                            Asiantuntijoita.<br>
                            Ohjelmistoja.<br>
                            Rennosti.
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Services Section -->
        <section id="palvelut" class="py-20 bg-black">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="text-center mb-16">
                    <h2 class="text-3xl md:text-4xl font-courier font-bold text-primary mb-4">
                        Palvelumme
                    </h2>
                    <p class="text-lg text-gray-300 max-w-2xl mx-auto">
                        Tarjoamme kattavan valikoiman digitaalisia palveluja yrityksille
                    </p>
                </div>
                
                <div class="grid md:grid-cols-3 gap-8">
                    <div class="text-center p-6 bg-gray-900 rounded-lg">
                        <div class="w-16 h-16 bg-primary text-white rounded-full flex items-center justify-center mx-auto mb-4">
                            <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                        </div>
                        <h3 class="text-xl font-courier font-semibold text-white mb-2">Konsultointi</h3>
                        <p class="text-gray-300">Ammattitaitoista neuvontaa ja strategista suunnittelua</p>
                    </div>
                    
                    <div class="text-center p-6 bg-gray-900 rounded-lg">
                        <div class="w-16 h-16 bg-primary text-white rounded-full flex items-center justify-center mx-auto mb-4">
                            <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"></path>
                            </svg>
                        </div>
                        <h3 class="text-xl font-courier font-semibold text-white mb-2">Kehitys</h3>
                        <p class="text-gray-300">Räätälöityjä ohjelmistoratkaisuja ja web-sovelluksia</p>
                    </div>
                    
                    <div class="text-center p-6 bg-gray-900 rounded-lg">
                        <div class="w-16 h-16 bg-primary text-white rounded-full flex items-center justify-center mx-auto mb-4">
                            <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z"></path>
                            </svg>
                        </div>
                        <h3 class="text-xl font-courier font-semibold text-white mb-2">Tuki</h3>
                        <p class="text-gray-300">Jatkuvaa tukea ja ylläpitoa digitaalisille ratkaisuille</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- About Section -->
        <section class="py-20 bg-black">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="grid md:grid-cols-2 gap-12 items-center">
                    <div>
                        <h2 class="text-3xl md:text-4xl font-courier font-bold text-primary mb-6">
                            Tietoa Replikasta
                        </h2>
                        <p class="text-lg text-gray-300 mb-6">
                            Replika on innovatiivinen teknologiayritys, joka keskittyy tarjoamaan 
                            korkealaatuisia digitaalisia ratkaisuja yrityksille. Meillä on vuosien 
                            kokemus alan parhaista käytännöistä ja uusimmista teknologioista.
                        </p>
                        <p class="text-lg text-gray-300 mb-8">
                            Tiimimme koostuu osaavista ammattilaisista, jotka ovat intohimoisia 
                            digitaalisen maailman kehittämisestä ja asiakkaidemme menestyksen 
                            edistämisestä.
                        </p>
                        <a href="#yhteystiedot" class="bg-primary hover:bg-primary-hover text-white px-6 py-3 rounded-lg font-medium transition duration-300">
                            Ota yhteyttä
                        </a>
                    </div>
                    <div class="text-center">
                        <div class="bg-gray-900 p-8 rounded-lg shadow-lg">
                            <div class="text-6xl text-primary mb-4">🚀</div>
                            <h3 class="text-2xl font-courier font-bold text-primary mb-2">Replika</h3>
                            <p class="text-gray-300">Innovaatiota ja laatua digitaalisiin ratkaisuihin</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer class="bg-black text-white py-12">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="grid md:grid-cols-3 gap-8">
                <div>
                    <h3 class="text-2xl font-courier font-bold text-primary mb-4">Replika</h3>
                    <p class="text-gray-300 mb-4">
                        Asiantuntevaa konsultointia ja kehitystä digitaalisiin ratkaisuihin.
                    </p>
                </div>
                
                <div id="yhteystiedot">
                    <h4 class="text-lg font-courier font-semibold mb-4">Yhteystiedot</h4>
                    <div class="text-gray-300 space-y-2">
                        <p>Sähköposti: info@replika.fi</p>
                        <p>Puhelin: +358 XX XXX XXXX</p>
                        <p>Osoite: Esimerkikatu 123, Helsinki</p>
                    </div>
                </div>
                
                <div>
                    <h4 class="text-lg font-courier font-semibold mb-4">Seuraa meitä</h4>
                    <div class="flex space-x-4">
                        <a href="#" class="text-gray-300 hover:text-primary transition duration-300">
                            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M24 4.557c-.883.392-1.832.656-2.828.775 1.017-.609 1.798-1.574 2.165-2.724-.951.564-2.005.974-3.127 1.195-.897-.957-2.178-1.555-3.594-1.555-3.179 0-5.515 2.966-4.797 6.045-4.091-.205-7.719-2.165-10.148-5.144-1.29 2.213-.669 5.108 1.523 6.574-.806-.026-1.566-.247-2.229-.616-.054 2.281 1.581 4.415 3.949 4.89-.693.188-1.452.232-2.224.084.626 1.956 2.444 3.379 4.6 3.419-2.07 1.623-4.678 2.348-7.29 2.04 2.179 1.397 4.768 2.212 7.548 2.212 9.142 0 14.307-7.721 13.995-14.646.962-.695 1.797-1.562 2.457-2.549z"/>
                            </svg>
                        </a>
                        <a href="#" class="text-gray-300 hover:text-primary transition duration-300">
                            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
                            </svg>
                        </a>
                    </div>
                </div>
            </div>
            
            <div class="border-t border-gray-700 mt-8 pt-8 text-center">
                <p class="text-gray-400">
                    &copy; 2024 Replika. Kaikki oikeudet pidätetään.
                </p>
            </div>
        </div>
    </footer>

    <script>
        function toggleMobileMenu() {
            const mobileMenu = document.getElementById('mobile-menu');
            const hamburgerIcon = document.getElementById('hamburger-icon');
            const crossIcon = document.getElementById('cross-icon');
            
            // Toggle menu visibility
            mobileMenu.classList.toggle('hidden');
            
            // Toggle between hamburger and cross icons
            hamburgerIcon.classList.toggle('hidden');
            crossIcon.classList.toggle('hidden');
        }
        
        // Smooth scrolling for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // D3.js Particle Animation System
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.svg = d3.select('#particle-container');
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.particleCount = 1000;
                this.animationState = 'forming'; // Start forming immediately
                this.sequenceStartTime = null; // Will be set when oval formation is complete
                
                this.initializeParticles();
                this.createParticleElements();
                this.startAnimation();
            }
            
            getResponsiveRadius() {
                // Scale particle radius based on viewport width
                // Mobile (< 768px): 0.3-0.8px
                // Tablet (768-1024px): 0.4-1.0px  
                // Desktop (> 1024px): 0.5-1.5px
                if (this.width < 768) {
                    return Math.random() * 0.5 + 0.3; // 0.3-0.8px for mobile
                } else if (this.width < 1024) {
                    return Math.random() * 0.6 + 0.4; // 0.4-1.0px for tablet
                } else {
                    return Math.random() * 1 + 0.5; // 0.5-1.5px for desktop
                }
            }
            
            initializeParticles() {
                for (let i = 0; i < this.particleCount; i++) {
                    const particle = {
                        id: i,
                        x: Math.random() * this.width,
                        y: Math.random() * this.height,
                        radius: this.getResponsiveRadius(),
                        opacity: Math.random() * 0.4 + 0.5,
                        wigglePhase: Math.random() * Math.PI * 2,
                        wiggleSpeed: 0.02 + Math.random() * 0.02,
                        wiggleAmplitude: 3 + Math.random() * 4,  // Much more wiggling for oval
                        // Star-like twinkling properties
                        twinklePhase: Math.random() * Math.PI * 2,
                        twinkleSpeed: 0.1 + Math.random() * 0.15, // Fast but visible twinkling
                        twinkleAmplitude: 0.4 + Math.random() * 0.3, // Random twinkling intensity (more pronounced)
                        baseOpacity: 0.5 + Math.random() * 0.3 // Random base brightness
                    };
                    
                    // Calculate oval positions (starting shape) - centered in hero
                    const ovalCoords = this.getOvalCoordinates(i);
                    particle.ovalX = this.width / 2 + ovalCoords.x; // Centered horizontally
                    particle.ovalY = this.height / 2 + ovalCoords.y; // Centered vertically
                    particle.baseOvalX = particle.ovalX;
                    particle.baseOvalY = particle.ovalY;
                    particle.currentBaseX = particle.baseOvalX; // Start with oval position
                    particle.currentBaseY = particle.baseOvalY;
                    
                    // Calculate lightbulb positions (middle shape)
                    const lightbulbCoords = this.getLightbulbCoordinates(i);
                    particle.lightbulbX = this.width / 2 + lightbulbCoords.x;
                    particle.lightbulbY = this.height * 0.7 + 70 + lightbulbCoords.y;
                    particle.baseLightbulbX = particle.lightbulbX;
                    particle.baseLightbulbY = particle.lightbulbY;
                    
                    // Calculate bot positions (third shape) - same location as lightbulb
                    const botCoords = this.getBotCoordinates(i);
                    particle.botX = this.width / 2 + botCoords.x;
                    particle.botY = this.height * 0.7 + 70 + botCoords.y;
                    particle.baseBotX = particle.botX;
                    particle.baseBotY = particle.botY;
                    
                    // Calculate chart positions (final shape) - same location as others
                    const chartCoords = this.getChartCoordinates(i);
                    particle.chartX = this.width / 2 + chartCoords.x;
                    particle.chartY = this.height * 0.7 + 70 + chartCoords.y;
                    particle.baseChartX = particle.chartX;
                    particle.baseChartY = particle.chartY;
                    
                    // Initialize currentOpacity with twinkling effect
                    const twinkle = Math.sin(particle.twinklePhase) * particle.twinkleAmplitude;
                    particle.currentOpacity = Math.max(0.1, Math.min(1.0, particle.baseOpacity + twinkle));
                    
                    this.particles.push(particle);
                }
            }
            
            createParticleElements() {
                this.svg.selectAll('circle')
                    .data(this.particles)
                    .enter()
                    .append('circle')
                    .attr('class', 'particle')
                    .attr('r', d => d.radius)
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('opacity', d => d.currentOpacity || d.baseOpacity);
            }
            
            getLightbulbCoordinates(index) {
                const scale = (Math.min(this.width, this.height) / 120) * 1.69; // 69% bigger than original (1.3 * 1.3)
                
                // Create outline based on exact SVG path coordinates
                const totalPerimeter = this.particleCount;
                const normalizedIndex = index / totalPerimeter;
                
                // Define sections based on SVG path segments (removed connection section)
                const rightSide = 0.22;      // Right side curve (22%, increased from 20%)
                const topArc = 0.32;         // Top semicircle (32%, increased from 30%)
                const leftSide = 0.22;       // Left side curve (22%, increased from 20%)
                const topLine = 0.12;        // Top horizontal line (12%, decreased from 15%)
                const bottomLine = 0.12;     // Bottom horizontal line (12%, increased from 10%)
                
                let x, y;
                
                if (normalizedIndex < rightSide) {
                    // Right side curve: MIRRORED from left side
                    const progress = normalizedIndex / rightSide;
                    const startX = 9, startY = 14;   // Mirror of left side start (9,14)
                    const endX = 6, endY = 8;        // Mirror of left side end (6,8)
                    
                    // Mirror the coordinates horizontally around center x=12
                    const mirrorStartX = 24 - startX; // 24 - 9 = 15
                    const mirrorEndX = 24 - endX;     // 24 - 6 = 18
                    
                    const t = progress;
                    x = mirrorStartX + t * (mirrorEndX - mirrorStartX) - Math.sin(t * Math.PI) * 1.5; // Mirror the curve (negative sin)
                    y = startY + t * (endY - startY);
                    
                } else if (normalizedIndex < rightSide + topArc) {
                    // Top semicircle: from (18,8) to (6,8) - FLIPPED 180 degrees, moved higher
                    const progress = (normalizedIndex - rightSide) / topArc;
                    const centerX = 12, centerY = 8, radius = 6; // Center at y=8 (same level as connection points)
                    const angle = Math.PI + progress * Math.PI; // Flipped: from π to 2π (bottom half of circle)
                    
                    x = centerX + radius * Math.cos(angle);
                    y = centerY + radius * Math.sin(angle);
                    
                } else if (normalizedIndex < rightSide + topArc + leftSide) {
                    // Left side curve: from (6,8) to (9,14)
                    const progress = (normalizedIndex - rightSide - topArc) / leftSide;
                    const startX = 6, startY = 8;
                    const endX = 9, endY = 14;
                    
                    // Bezier curve: C6 9 6.2 10.2 7.5 11.5C8.2 12.2 8.8 13 9 14
                    const t = progress;
                    x = startX + t * (endX - startX) + Math.sin(t * Math.PI) * 1.5; // Slight curve outward
                    y = startY + t * (endY - startY);
                    
                } else if (normalizedIndex < rightSide + topArc + leftSide + topLine) {
                    // Top horizontal line: moved 10 pixels down from previous position
                    const progress = (normalizedIndex - rightSide - topArc - leftSide) / topLine;
                    x = 9 + progress * (15 - 9);
                    y = 17.25; // Moved down by 1.25 units (10 pixels at 8x scale)
                    
                } else {
                    // Bottom horizontal line: moved 10 pixels down from previous position
                    const progress = (normalizedIndex - rightSide - topArc - leftSide - topLine) / bottomLine;
                    x = 10 + progress * (14 - 10);
                    y = 20.25; // Moved down by 1.25 units (10 pixels at 8x scale)
                }
                
                // Scale and center the coordinates
                x = (x - 12) * scale; // Center at x=12, then scale
                y = (y - 12) * scale; // Center at y=12, then scale
                
                // Add small randomness
                const randomX = (Math.random() - 0.5) * 2;
                const randomY = (Math.random() - 0.5) * 2;
                
                return { x: x + randomX, y: y + randomY };
            }
            
            getBotCoordinates(index) {
                const scale = (Math.min(this.width, this.height) / 120) * 1.69; // 69% bigger than original (1.3 * 1.3)
                
                // Create outline based on exact SVG path coordinates
                const totalPerimeter = this.particleCount;
                const normalizedIndex = index / totalPerimeter;
                
                // Define sections based on SVG path segments
                const mainBody = 0.60;        // Main rectangular body (60%)
                const antenna = 0.15;         // Top antenna (15%)
                const leftArm = 0.05;         // Left antenna arm (5%)
                const rightArm = 0.05;        // Right antenna arm (5%)
                const leftEye = 0.075;        // Left eye (7.5%)
                const rightEye = 0.075;       // Right eye (7.5%)
                
                let x, y;
                
                if (normalizedIndex < mainBody) {
                    // Main body - rounded rectangle from (6,8) to (18,20)
                    const progress = normalizedIndex / mainBody;
                    const bodyWidth = 18 - 6; // 12 units wide
                    const bodyHeight = 20 - 8; // 12 units tall
                    
                    // Trace the perimeter of rounded rectangle
                    const perimeter = 2 * (bodyWidth + bodyHeight);
                    const perimeterProgress = progress * perimeter;
                    
                    if (perimeterProgress < bodyWidth) {
                        // Top edge
                        x = 6 + perimeterProgress;
                        y = 8;
                    } else if (perimeterProgress < bodyWidth + bodyHeight) {
                        // Right edge
                        x = 18;
                        y = 8 + (perimeterProgress - bodyWidth);
                    } else if (perimeterProgress < 2 * bodyWidth + bodyHeight) {
                        // Bottom edge
                        x = 18 - (perimeterProgress - bodyWidth - bodyHeight);
                        y = 20;
                    } else {
                        // Left edge
                        x = 6;
                        y = 20 - (perimeterProgress - 2 * bodyWidth - bodyHeight);
                    }
                    
                } else if (normalizedIndex < mainBody + antenna) {
                    // Antenna: vertical line from (12,8) to (12,4) then horizontal to (8,4)
                    const progress = (normalizedIndex - mainBody) / antenna;
                    if (progress < 0.5) {
                        // Vertical part
                        x = 12;
                        y = 8 - progress * 2 * 4; // From y=8 to y=4
                    } else {
                        // Horizontal part
                        x = 12 - (progress - 0.5) * 2 * 4; // From x=12 to x=8
                        y = 4;
                    }
                    
                } else if (normalizedIndex < mainBody + antenna + leftArm) {
                    // Left antenna arm: M2 14H4
                    const progress = (normalizedIndex - mainBody - antenna) / leftArm;
                    x = 2 + progress * 2; // From x=2 to x=4
                    y = 14;
                    
                } else if (normalizedIndex < mainBody + antenna + leftArm + rightArm) {
                    // Right antenna arm: M20 14H22
                    const progress = (normalizedIndex - mainBody - antenna - leftArm) / rightArm;
                    x = 20 + progress * 2; // From x=20 to x=22
                    y = 14;
                    
                } else if (normalizedIndex < mainBody + antenna + leftArm + rightArm + leftEye) {
                    // Left eye: M15 13V15
                    const progress = (normalizedIndex - mainBody - antenna - leftArm - rightArm) / leftEye;
                    x = 15;
                    y = 13 + progress * 2; // From y=13 to y=15
                    
                } else {
                    // Right eye: M9 13V15
                    const progress = (normalizedIndex - mainBody - antenna - leftArm - rightArm - leftEye) / rightEye;
                    x = 9;
                    y = 13 + progress * 2; // From y=13 to y=15
                }
                
                // Scale and center the coordinates
                x = (x - 12) * scale; // Center at x=12, then scale
                y = (y - 12) * scale; // Center at y=12, then scale
                
                // Add small randomness
                const randomX = (Math.random() - 0.5) * 2;
                const randomY = (Math.random() - 0.5) * 2;
                
                return { x: x + randomX, y: y + randomY };
            }
            
            getChartCoordinates(index) {
                const scale = (Math.min(this.width, this.height) / 120) * 1.69; // 69% bigger than original (1.3 * 1.3)
                
                // Create outline based on exact SVG path coordinates
                const totalPerimeter = this.particleCount;
                const normalizedIndex = index / totalPerimeter;
                
                // Define sections based on SVG path segments
                const lineChart = 0.30;       // Line chart path (30%)
                const bar1 = 0.14;            // Bar at x=4 (14%)
                const bar2 = 0.14;            // Bar at x=8 (14%)
                const bar3 = 0.14;            // Bar at x=12 (14%)
                const bar4 = 0.14;            // Bar at x=16 (14%)
                const bar5 = 0.14;            // Bar at x=20 (14%)
                
                let x, y;
                
                if (normalizedIndex < lineChart) {
                    // Line chart: M22 3 -> L13.354 11.646 -> L9.354 8.354 -> L2 15
                    const progress = normalizedIndex / lineChart;
                    
                    if (progress < 0.33) {
                        // First segment: (22,3) to (13.354,11.646)
                        const segmentProgress = progress / 0.33;
                        x = 22 + segmentProgress * (13.354 - 22);
                        y = 3 + segmentProgress * (11.646 - 3);
                    } else if (progress < 0.66) {
                        // Second segment: (13.354,11.646) to (9.354,8.354)
                        const segmentProgress = (progress - 0.33) / 0.33;
                        x = 13.354 + segmentProgress * (9.354 - 13.354);
                        y = 11.646 + segmentProgress * (8.354 - 11.646);
                    } else {
                        // Third segment: (9.354,8.354) to (2,15)
                        const segmentProgress = (progress - 0.66) / 0.34;
                        x = 9.354 + segmentProgress * (2 - 9.354);
                        y = 8.354 + segmentProgress * (15 - 8.354);
                    }
                    
                } else if (normalizedIndex < lineChart + bar1) {
                    // Bar 1: M4 18V21
                    const progress = (normalizedIndex - lineChart) / bar1;
                    x = 4;
                    y = 18 + progress * (21 - 18); // From y=18 to y=21
                    
                } else if (normalizedIndex < lineChart + bar1 + bar2) {
                    // Bar 2: M8 14V21
                    const progress = (normalizedIndex - lineChart - bar1) / bar2;
                    x = 8;
                    y = 14 + progress * (21 - 14); // From y=14 to y=21
                    
                } else if (normalizedIndex < lineChart + bar1 + bar2 + bar3) {
                    // Bar 3: M12 16V21
                    const progress = (normalizedIndex - lineChart - bar1 - bar2) / bar3;
                    x = 12;
                    y = 16 + progress * (21 - 16); // From y=16 to y=21
                    
                } else if (normalizedIndex < lineChart + bar1 + bar2 + bar3 + bar4) {
                    // Bar 4: M16 14V21
                    const progress = (normalizedIndex - lineChart - bar1 - bar2 - bar3) / bar4;
                    x = 16;
                    y = 14 + progress * (21 - 14); // From y=14 to y=21
                    
                } else {
                    // Bar 5: M20 10V21
                    const progress = (normalizedIndex - lineChart - bar1 - bar2 - bar3 - bar4) / bar5;
                    x = 20;
                    y = 10 + progress * (21 - 10); // From y=10 to y=21
                }
                
                // Scale and center the coordinates
                x = (x - 12) * scale; // Center at x=12, then scale
                y = (y - 12) * scale; // Center at y=12, then scale
                
                // Add small randomness
                const randomX = (Math.random() - 0.5) * 2;
                const randomY = (Math.random() - 0.5) * 2;
                
                return { x: x + randomX, y: y + randomY };
            }
            
            getOvalCoordinates(index) {
                const ovalWidth = this.width * 0.8;   // 80% of viewport width
                const ovalHeight = this.height * 0.6; // 60% of viewport height
                
                // Create filled oval by distributing particles uniformly
                const angle = (index / this.particleCount) * Math.PI * 2;
                const radiusVariation = Math.sqrt(Math.random()); // For uniform distribution inside oval
                const currentAngle = angle + (Math.random() - 0.5) * 0.3; // Add slight randomness
                
                const x = radiusVariation * (ovalWidth / 2) * Math.cos(currentAngle);
                const y = radiusVariation * (ovalHeight / 2) * Math.sin(currentAngle);
                
                return { x: x, y: y };
            }
            
            updateWiggle() {
                // Calculate continuous scaling effect for all shapes
                const time = Date.now() / 1000;
                const sizeVariation = Math.sin(time * 0.8) * 50;
                const baseWidth = this.width * 0.8;
                const scaleFactor = (baseWidth + sizeVariation) / baseWidth;
                
                this.particles.forEach((particle, index) => {
                    // ALWAYS update twinkling for ALL particles regardless of animation state
                    particle.twinklePhase += particle.twinkleSpeed;
                    const twinkle = Math.sin(particle.twinklePhase) * particle.twinkleAmplitude;
                    particle.currentOpacity = Math.max(0.1, Math.min(1.0, particle.baseOpacity + twinkle));
                    
                    
                    // Apply continuous scaling to all shape positions based on current animation state
                    // Don't update during transitions as particles are actively moving
                    if (this.animationState === 'oval') {
                        // Scale oval positions
                        const originalX = particle.baseOvalX - this.width / 2;
                        const originalY = particle.baseOvalY - this.height / 2;
                        particle.currentBaseX = this.width / 2 + originalX * scaleFactor;
                        particle.currentBaseY = this.height / 2 + originalY * scaleFactor;
                    } else if (this.animationState === 'lightbulb') {
                        // Scale lightbulb positions with enhanced scaling effect
                        const enhancedScaleFactor = 1 + (scaleFactor - 1) * 2; // Double the scaling effect
                        const originalX = particle.baseLightbulbX - this.width / 2;
                        const originalY = particle.baseLightbulbY - (this.height * 0.7 + 70);
                        particle.currentBaseX = this.width / 2 + originalX * enhancedScaleFactor;
                        particle.currentBaseY = this.height * 0.7 + 70 + originalY * enhancedScaleFactor;
                    } else if (this.animationState === 'bot') {
                        // Scale bot positions with enhanced scaling effect
                        const enhancedScaleFactor = 1 + (scaleFactor - 1) * 2; // Double the scaling effect
                        const originalX = particle.baseBotX - this.width / 2;
                        const originalY = particle.baseBotY - (this.height * 0.7 + 70);
                        particle.currentBaseX = this.width / 2 + originalX * enhancedScaleFactor;
                        particle.currentBaseY = this.height * 0.7 + 70 + originalY * enhancedScaleFactor;
                    } else if (this.animationState === 'chart') {
                        // Scale chart positions with enhanced scaling effect
                        const enhancedScaleFactor = 1 + (scaleFactor - 1) * 2; // Double the scaling effect
                        const originalX = particle.baseChartX - this.width / 2;
                        const originalY = particle.baseChartY - (this.height * 0.7 + 70);
                        particle.currentBaseX = this.width / 2 + originalX * enhancedScaleFactor;
                        particle.currentBaseY = this.height * 0.7 + 70 + originalY * enhancedScaleFactor;
                    }
                    // Note: During transition states (transitioning, transitioning-to-bot, etc.), 
                    // we don't update currentBaseX/Y as they are controlled by the animation functions
                    
                    // Update wiggle phase
                    particle.wigglePhase += particle.wiggleSpeed;
                    
                    // Calculate wiggle offset
                    const wiggleX = Math.sin(particle.wigglePhase) * particle.wiggleAmplitude;
                    const wiggleY = Math.cos(particle.wigglePhase * 0.7) * particle.wiggleAmplitude;
                    
                    // Apply wiggle to current base position (which can be interpolated during transitions)
                    particle.currentX = (particle.currentBaseX || particle.baseArrowX) + wiggleX;
                    particle.currentY = (particle.currentBaseY || particle.baseArrowY) + wiggleY;
                });
            }
            
            transitionToOval() {
                // Immediate transition to oval positions with smooth easing
                this.svg.selectAll('circle')
                    .transition()
                    .duration(3000)
                    .ease(d3.easeCubicOut)
                    .attr('cx', d => d.baseOvalX)
                    .attr('cy', d => d.baseOvalY);
                    // Remove fixed opacity to allow twinkling effect
                
                this.animationState = 'oval';
            }
            
            transitionToLightbulb() {
                // Change state immediately to stop pulsating effect
                this.animationState = 'transitioning';
                
                // Gradually move each particle from oval to lightbulb position
                this.particles.forEach((particle, index) => {
                    // Stagger the start time slightly for more organic movement
                    const delay = (index / this.particleCount) * 1000; // Spread over 1 second
                    
                    setTimeout(() => {
                        this.animateParticleToLightbulb(particle);
                    }, delay);
                });
                
                // Set intermediate state after first transition completes
                setTimeout(() => {
                    this.animationState = 'lightbulb';
                    // Start transition to bot after 2 seconds in lightbulb state
                    setTimeout(() => {
                        this.transitionToBot();
                    }, 2000);
                }, 2000); // 1s stagger + 1s duration
            }
            
            animateParticleToLightbulb(particle) {
                const startTime = Date.now();
                const duration = 1000; // 1 second for each particle to reach lightbulb
                // Use current scaled position (from pulsating) as start position for smooth transition
                const startX = particle.currentBaseX || particle.baseOvalX;
                const startY = particle.currentBaseY || particle.baseOvalY;
                const endX = particle.baseLightbulbX;
                const endY = particle.baseLightbulbY;
                
                // Add random curved flight path
                const controlX1 = startX + (Math.random() - 0.5) * 400;
                const controlY1 = startY + (Math.random() - 0.5) * 400;
                const controlX2 = endX + (Math.random() - 0.5) * 300;
                const controlY2 = endY + (Math.random() - 0.5) * 300;
                
                const animateStep = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Use easeInQuart for accelerating transition (slow start, fast end)
                    const easeProgress = progress * progress * progress * progress;
                    
                    // Bezier curve interpolation for curved path
                    const t = easeProgress;
                    const oneMinusT = 1 - t;
                    const oneMinusT2 = oneMinusT * oneMinusT;
                    const oneMinusT3 = oneMinusT2 * oneMinusT;
                    const t2 = t * t;
                    const t3 = t2 * t;
                    
                    particle.currentBaseX = oneMinusT3 * startX + 3 * oneMinusT2 * t * controlX1 + 3 * oneMinusT * t2 * controlX2 + t3 * endX;
                    particle.currentBaseY = oneMinusT3 * startY + 3 * oneMinusT2 * t * controlY1 + 3 * oneMinusT * t2 * controlY2 + t3 * endY;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateStep);
                    } else {
                        // Ensure final position is exact
                        particle.currentBaseX = endX;
                        particle.currentBaseY = endY;
                    }
                };
                
                requestAnimationFrame(animateStep);
            }
            
            transitionToBot() {
                // Change state immediately to maintain scaling continuity
                this.animationState = 'transitioning-to-bot';
                
                // Gradually move each particle from lightbulb to bot position
                this.particles.forEach((particle, index) => {
                    // Stagger the start time slightly for more organic movement
                    const delay = (index / this.particleCount) * 1000; // Spread over 1 second
                    
                    setTimeout(() => {
                        this.animateParticleToBot(particle);
                    }, delay);
                });
                
                // Set intermediate state after transition completes
                setTimeout(() => {
                    this.animationState = 'bot';
                    // Start transition to chart after 2 seconds in bot state
                    setTimeout(() => {
                        this.transitionToChart();
                    }, 2000);
                }, 2000); // 1s stagger + 1s duration
            }
            
            animateParticleToBot(particle) {
                const startTime = Date.now();
                const duration = 1000; // 1 second for each particle to reach bot
                // Use current scaled positions for smooth transition
                const startX = particle.currentBaseX || particle.baseLightbulbX;
                const startY = particle.currentBaseY || particle.baseLightbulbY;
                const endX = particle.baseBotX;
                const endY = particle.baseBotY;
                
                // Add random curved flight path with increased randomness
                const controlX1 = startX + (Math.random() - 0.5) * 300;
                const controlY1 = startY + (Math.random() - 0.5) * 300;
                const controlX2 = endX + (Math.random() - 0.5) * 200;
                const controlY2 = endY + (Math.random() - 0.5) * 200;
                
                const animateStep = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Use easeInQuart for accelerating transition (slow start, fast end)
                    const easeProgress = progress * progress * progress * progress;
                    
                    // Bezier curve interpolation for curved path
                    const t = easeProgress;
                    const oneMinusT = 1 - t;
                    const oneMinusT2 = oneMinusT * oneMinusT;
                    const oneMinusT3 = oneMinusT2 * oneMinusT;
                    const t2 = t * t;
                    const t3 = t2 * t;
                    
                    particle.currentBaseX = oneMinusT3 * startX + 3 * oneMinusT2 * t * controlX1 + 3 * oneMinusT * t2 * controlX2 + t3 * endX;
                    particle.currentBaseY = oneMinusT3 * startY + 3 * oneMinusT2 * t * controlY1 + 3 * oneMinusT * t2 * controlY2 + t3 * endY;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateStep);
                    } else {
                        // Ensure final position is exact
                        particle.currentBaseX = endX;
                        particle.currentBaseY = endY;
                    }
                };
                
                requestAnimationFrame(animateStep);
            }
            
            transitionToChart() {
                // Change state immediately to maintain scaling continuity
                this.animationState = 'transitioning-to-chart';
                
                // Gradually move each particle from bot to chart position
                this.particles.forEach((particle, index) => {
                    // Stagger the start time slightly for more organic movement
                    const delay = (index / this.particleCount) * 1000; // Spread over 1 second
                    
                    setTimeout(() => {
                        this.animateParticleToChart(particle);
                    }, delay);
                });
                
                // Set intermediate state after transition completes
                setTimeout(() => {
                    this.animationState = 'chart';
                    // Start transition back to oval after 2 seconds in chart state
                    setTimeout(() => {
                        this.transitionToOval();
                    }, 2000);
                }, 2000); // 1s stagger + 1s duration
            }
            
            animateParticleToChart(particle) {
                const startTime = Date.now();
                const duration = 1000; // 1 second for each particle to reach chart
                // Use current scaled positions for smooth transition
                const startX = particle.currentBaseX || particle.baseBotX;
                const startY = particle.currentBaseY || particle.baseBotY;
                const endX = particle.baseChartX;
                const endY = particle.baseChartY;
                
                // Add random curved flight path with increased randomness
                const controlX1 = startX + (Math.random() - 0.5) * 300;
                const controlY1 = startY + (Math.random() - 0.5) * 300;
                const controlX2 = endX + (Math.random() - 0.5) * 200;
                const controlY2 = endY + (Math.random() - 0.5) * 200;
                
                const animateStep = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Use easeInQuart for accelerating transition (slow start, fast end)
                    const easeProgress = progress * progress * progress * progress;
                    
                    // Bezier curve interpolation for curved path
                    const t = easeProgress;
                    const oneMinusT = 1 - t;
                    const oneMinusT2 = oneMinusT * oneMinusT;
                    const oneMinusT3 = oneMinusT2 * oneMinusT;
                    const t2 = t * t;
                    const t3 = t2 * t;
                    
                    particle.currentBaseX = oneMinusT3 * startX + 3 * oneMinusT2 * t * controlX1 + 3 * oneMinusT * t2 * controlX2 + t3 * endX;
                    particle.currentBaseY = oneMinusT3 * startY + 3 * oneMinusT2 * t * controlY1 + 3 * oneMinusT * t2 * controlY2 + t3 * endY;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateStep);
                    } else {
                        // Ensure final position is exact
                        particle.currentBaseX = endX;
                        particle.currentBaseY = endY;
                    }
                };
                
                requestAnimationFrame(animateStep);
            }
            
            transitionToOval() {
                // Change state immediately to maintain scaling continuity
                this.animationState = 'transitioning-to-oval';
                
                // Gradually move each particle from chart back to oval position
                this.particles.forEach((particle, index) => {
                    // Stagger the start time slightly for more organic movement
                    const delay = (index / this.particleCount) * 1000; // Spread over 1 second
                    
                    setTimeout(() => {
                        this.animateParticleToOval(particle);
                    }, delay);
                });
                
                // Set final state after transition completes
                setTimeout(() => {
                    this.animationState = 'oval';
                    // Reset sequence start time for potential next cycle
                    this.sequenceStartTime = Date.now();
                }, 2000); // 1s stagger + 1s duration
            }
            
            animateParticleToOval(particle) {
                const startTime = Date.now();
                const duration = 1000; // 1 second for each particle to reach oval
                // Use current scaled positions for smooth transition
                const startX = particle.currentBaseX || particle.baseChartX;
                const startY = particle.currentBaseY || particle.baseChartY;
                const endX = particle.baseOvalX;
                const endY = particle.baseOvalY;
                
                // Add random curved flight path
                const controlX1 = startX + (Math.random() - 0.5) * 400;
                const controlY1 = startY + (Math.random() - 0.5) * 400;
                const controlX2 = endX + (Math.random() - 0.5) * 300;
                const controlY2 = endY + (Math.random() - 0.5) * 300;
                
                const animateStep = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Use easeInQuart for accelerating transition (slow start, fast end)
                    const easeProgress = progress * progress * progress * progress;
                    
                    // Bezier curve interpolation for curved path
                    const t = easeProgress;
                    const oneMinusT = 1 - t;
                    const oneMinusT2 = oneMinusT * oneMinusT;
                    const oneMinusT3 = oneMinusT2 * oneMinusT;
                    const t2 = t * t;
                    const t3 = t2 * t;
                    
                    particle.currentBaseX = oneMinusT3 * startX + 3 * oneMinusT2 * t * controlX1 + 3 * oneMinusT * t2 * controlX2 + t3 * endX;
                    particle.currentBaseY = oneMinusT3 * startY + 3 * oneMinusT2 * t * controlY1 + 3 * oneMinusT * t2 * controlY2 + t3 * endY;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateStep);
                    } else {
                        // Ensure final position is exact
                        particle.currentBaseX = endX;
                        particle.currentBaseY = endY;
                    }
                };
                
                requestAnimationFrame(animateStep);
            }
            
            animate() {
                // Check if it's time to start the sequence (after 3 seconds in oval state)
                if (this.sequenceStartTime) {
                    const currentTime = Date.now();
                    const timeElapsed = currentTime - this.sequenceStartTime;
                    
                    if (timeElapsed >= 3000 && this.animationState === 'oval') {
                        this.transitionToLightbulb();
                    }
                }
                
                this.updateWiggle();
                
                this.svg.selectAll('circle')
                    .attr('cx', d => d.currentX || d.baseArrowX)
                    .attr('cy', d => d.currentY || d.baseArrowY)
                    .attr('r', d => d.radius) // Update radius for responsive scaling
                    .style('opacity', d => d.currentOpacity || d.opacity); // Use style instead of attr to override transitions
                
                requestAnimationFrame(() => this.animate());
            }
            
            startAnimation() {
                // Start with oval formation
                this.svg.selectAll('circle')
                    .transition()
                    .duration(3000)
                    .ease(d3.easeCubicOut)
                    .attr('cx', d => d.baseOvalX)
                    .attr('cy', d => d.baseOvalY)
                    // Remove fixed opacity to allow twinkling effect
                    .on('end', () => {
                        // Set the sequence start time when oval formation is complete
                        if (!this.sequenceStartTime) {
                            this.sequenceStartTime = Date.now();
                        }
                    });
                
                this.animationState = 'oval';
                this.animate();
            }
            
            handleResize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                
                // Recalculate positions and radius for all particles
                this.particles.forEach((particle, i) => {
                    // Update particle radius based on new viewport width
                    particle.radius = this.getResponsiveRadius();
                    // Lightbulb positions
                    const lightbulbCoords = this.getLightbulbCoordinates(i);
                    particle.lightbulbX = this.width / 2 + lightbulbCoords.x;
                    particle.lightbulbY = this.height * 0.7 + 70 + lightbulbCoords.y;
                    particle.baseLightbulbX = particle.lightbulbX;
                    particle.baseLightbulbY = particle.lightbulbY;
                    
                    // Bot positions - same location as lightbulb
                    const botCoords = this.getBotCoordinates(i);
                    particle.botX = this.width / 2 + botCoords.x;
                    particle.botY = this.height * 0.7 + 70 + botCoords.y;
                    particle.baseBotX = particle.botX;
                    particle.baseBotY = particle.botY;
                    
                    // Chart positions - same location as others
                    const chartCoords = this.getChartCoordinates(i);
                    particle.chartX = this.width / 2 + chartCoords.x;
                    particle.chartY = this.height * 0.7 + 70 + chartCoords.y;
                    particle.baseChartX = particle.chartX;
                    particle.baseChartY = particle.chartY;
                    
                    // Oval positions - centered in hero
                    const ovalCoords = this.getOvalCoordinates(i);
                    particle.ovalX = this.width / 2 + ovalCoords.x; // Centered horizontally
                    particle.ovalY = this.height / 2 + ovalCoords.y; // Centered vertically
                    particle.baseOvalX = particle.ovalX;
                    particle.baseOvalY = particle.ovalY;
                });
            }
        }
        
        // Initialize particle system
        let particleSystem;
        
        function initializeParticleSystem() {
            particleSystem = new ParticleSystem();
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (particleSystem) {
                particleSystem.handleResize();
            }
        });
        
        // Initialize particle system when page loads
        document.addEventListener('DOMContentLoaded', initializeParticleSystem);
    </script>
</body>
</html>